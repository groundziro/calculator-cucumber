<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Memory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Calculator with Cucumber tests</a> &gt; <a href="index.source.html" class="el_package">calculator</a> &gt; <span class="el_source">Memory.java</span></div><h1>Memory.java</h1><pre class="source lang-java linenums">package calculator;

import visitor.Evaluator;
import visitor.Printer;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

/**
 * Cette classe contient la mémoire de notre programme de manière LIFO
 */
public class Memory {
    private ArrayList&lt;Expression&gt; mem;
    private int max;
<span class="fc" id="L18">    private final Printer p = new Printer(Notation.PREFIX);</span>
<span class="fc" id="L19">    private boolean alreadySaved = false;</span>


<span class="fc" id="L22">    public Memory(int size){</span>
<span class="fc" id="L23">        mem = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L24">        max = size;</span>
<span class="fc" id="L25">    }</span>

<span class="fc" id="L27">    public Memory(){</span>
<span class="fc" id="L28">        mem = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L29">        max = 1;</span>
<span class="fc" id="L30">    }</span>


    /**
     * Sert à ajouter une expression à la mémoire
     * @param e Expression à rajouter
     */
    public void add(Expression e){
<span class="fc" id="L38">        mem.add(e);</span>
<span class="fc" id="L39">        updateMem();</span>

<span class="fc" id="L41">    }</span>

    private void updateMem(){
<span class="fc bfc" id="L44" title="All 4 branches covered.">        while (isFull() &amp;&amp; mem.size()!=max){</span>
<span class="fc" id="L45">            mem = new ArrayList&lt;&gt;(mem.subList(1,mem.size()));</span>
        }
<span class="fc" id="L47">    }</span>

    public void addAll(List&lt;Expression&gt; elist){
<span class="fc bfc" id="L50" title="All 2 branches covered.">        for (Expression e: elist) {</span>
<span class="fc" id="L51">            add(e);</span>
<span class="fc" id="L52">        }</span>
<span class="fc" id="L53">    }</span>

    /**
     * Vérifie si notre mémoire est pleine
     * @return Vrai si celle-ci est pleine
     */
    public boolean isFull(){
<span class="fc bfc" id="L60" title="All 2 branches covered.">        return mem.size()&gt;=max;</span>
    }

    /**
     * Cette fonction sert à récupérer une expression dans la mémoire
     * @param index Indice de la profondeur où on doit aller rechercher l'expression
     *              =&gt; size-1 c'est le dessus de la pile et 0 c'est la base de la pile
     * @return L'expression recherchée
     */
    public Expression get(int index){
<span class="fc" id="L70">        int _max = mem.size()-1;</span>
<span class="fc" id="L71">        int cur = _max - index;</span>
<span class="fc" id="L72">        return mem.get(cur);</span>
    }

    /**
     * Sert à mettre à jour la taille max de notre mémoire si on se rend compte en cours d'exécution
     * que celle-ci est trop petite
     * @param max Taille maximum de la mémoire
     */
    public void setMax(int max) {
<span class="fc" id="L81">        this.max = (Math.max(max, 1));</span>
<span class="fc" id="L82">        updateMem();</span>
<span class="fc" id="L83">    }</span>

    //Pour le testing
    public int size(){
<span class="fc" id="L87">        return mem.size();</span>
    }

    public void print(){
<span class="fc" id="L91">        System.out.println(getLog());</span>
<span class="fc" id="L92">    }</span>

    /**
     * Sert à obtenir un log cohérent pour la sauvegarde
     * @return Un log de ce que contient la pile
     */
    public String getLog(){
<span class="fc" id="L99">        StringBuilder log = new StringBuilder();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (Expression e : mem){</span>
<span class="fc" id="L101">            e.accept(p);</span>
<span class="fc" id="L102">            log.append(p.getStr()).append(&quot;\n&quot;);</span>
<span class="fc" id="L103">        }</span>
<span class="fc" id="L104">        return log.toString();</span>
    }


    /**
     * Sert à charger un fichier de mémoire
     * @param path Chemin du fichier en question
     */
    public void load(String path){
        try{
<span class="fc" id="L114">            File reader = new File(path);</span>
<span class="fc" id="L115">            Scanner scan = new Scanner(reader);</span>
<span class="fc" id="L116">            ArrayList&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            while(scan.hasNextLine()){</span>
<span class="fc" id="L118">                String data = scan.nextLine();</span>
<span class="fc" id="L119">                expressions.add(parse(data));</span>
<span class="fc" id="L120">            }</span>
<span class="fc" id="L121">            scan.close();</span>
<span class="fc" id="L122">            setMax(expressions.size());</span>
<span class="fc" id="L123">            addAll(expressions);</span>
<span class="fc" id="L124">            print();</span>
<span class="nc" id="L125">        }catch (FileNotFoundException | IllegalConstruction ignored){</span>

<span class="fc" id="L127">        }</span>
<span class="fc" id="L128">    }</span>

    private Expression parse(String data) throws IllegalConstruction {
<span class="fc" id="L131">        ArrayList&lt;String&gt; str = new ArrayList&lt;&gt;(Arrays.asList(data.split(&quot; | , &quot;)));</span>
<span class="fc" id="L132">        String op = str.get(0);</span>
<span class="fc" id="L133">        ArrayList&lt;String&gt; expression = getExp(str.subList(1,str.size()));</span>
<span class="fc" id="L134">        expression.remove(0);</span>
<span class="fc" id="L135">        ArrayList&lt;Expression&gt; total = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L136">        ArrayList&lt;ArrayList&lt;String&gt;&gt; exps = getExps(expression);</span>
        //System.out.println(Arrays.toString(exps.get(0).toArray()));
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (ArrayList&lt;String&gt; exp:exps) {</span>
            //System.out.println(exp);
<span class="fc" id="L140">            Expression e = parseRec(exp,new ArrayList&lt;&gt;());</span>
<span class="fc" id="L141">            total.add(e);</span>
<span class="fc" id="L142">        }</span>
<span class="fc" id="L143">        return getOp(op,total);</span>
    }



    private ArrayList&lt;String&gt; getExp(List&lt;String&gt; data){
<span class="fc" id="L149">        ArrayList&lt;String&gt; str = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L150">        int depth = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (String s:data) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (s.equals(&quot;)&quot;)) {</span>
<span class="fc" id="L153">                depth -= 1;</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                if (depth==0)</span>
<span class="fc" id="L155">                    break;</span>
            }
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (s.equals(&quot;(&quot;))</span>
<span class="fc" id="L158">                depth+=1;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (!s.equals(&quot;,&quot;))</span>
<span class="fc" id="L160">                str.add(s);</span>
<span class="fc" id="L161">        }</span>
<span class="fc" id="L162">        return str;</span>
    }

    private ArrayList&lt;ArrayList&lt;String&gt;&gt; getExps(List&lt;String&gt; expression) {
<span class="fc" id="L166">        int depth = 0;</span>
<span class="fc" id="L167">        ArrayList&lt;ArrayList&lt;String&gt;&gt; expressions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 0; i&lt;expression.size();i++) {</span>
<span class="fc" id="L169">            String s = expression.get(i);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (s.equals(&quot;(&quot;))</span>
<span class="fc" id="L171">                depth++;</span>
<span class="pc bpc" id="L172" title="1 of 6 branches missed.">            if (!isAlphaNum(s) &amp;&amp; depth==0 &amp;&amp; !s.equals(&quot;,&quot;)){</span>
<span class="fc" id="L173">                expressions.add(getExp(expression.subList(i,expression.size())));</span>
            }
<span class="fc bfc" id="L175" title="All 4 branches covered.">            if (isAlphaNum(s) &amp;&amp; depth==0) {</span>
<span class="fc" id="L176">                ArrayList&lt;String&gt; num = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">                num.add(s);</span>
<span class="fc" id="L178">                expressions.add(num);</span>
            }
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (s.equals(&quot;)&quot;))</span>
<span class="fc" id="L181">                depth--;</span>
        }
<span class="fc" id="L183">        return expressions;</span>
    }

    private Expression parseRec(List&lt;String&gt; data, ArrayList&lt;Expression&gt; list) {
<span class="fc bfc" id="L187" title="All 4 branches covered.">        if (!isAlphaNum(data.get(0)) &amp;&amp; !data.get(0).equals(&quot;(&quot;)) {</span>
<span class="fc" id="L188">            ArrayList&lt;Expression&gt; newL = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L189">            parseRec(getExp(data.subList(1, data.size())), newL);</span>
<span class="fc" id="L190">            return getOp(data.get(0), newL);</span>
<span class="pc bpc" id="L191" title="1 of 4 branches missed.">        } else if (isAlphaNum(data.get(0)) &amp;&amp; data.size() == 1) {</span>
<span class="fc" id="L192">            return new MyNumber(Integer.parseInt(data.get(0)));</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        } else if (data.get(0).equals(&quot;(&quot;)){</span>
<span class="fc" id="L194">            ArrayList&lt;ArrayList&lt;String&gt;&gt; exps = getExps(data.subList(1, data.size()));</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (ArrayList&lt;String&gt; str :exps) {</span>
<span class="fc" id="L196">                list.add(parseRec(str,new ArrayList&lt;&gt;()));</span>
<span class="fc" id="L197">            }</span>
        }
<span class="fc" id="L199">        return null;</span>
    }

    private Expression getOp(String s, ArrayList&lt;Expression&gt; total) {
        try {
<span class="fc" id="L204">            Expression exp = null;</span>
<span class="pc bpc" id="L205" title="4 of 10 branches missed.">            switch (s) {</span>
                case &quot;+&quot;:
<span class="fc" id="L207">                    exp = new Plus(total);</span>
<span class="fc" id="L208">                    break;</span>
                case &quot;-&quot;:
<span class="fc" id="L210">                    exp = new Minus(total);</span>
<span class="fc" id="L211">                    break;</span>
                case &quot;/&quot;:
<span class="nc" id="L213">                    exp = new Divides(total);</span>
<span class="nc" id="L214">                    break;</span>
                case &quot;*&quot;:
<span class="fc" id="L216">                    exp = new Times(total);</span>
<span class="fc" id="L217">                    break;</span>
                case &quot;xor&quot;:
<span class="nc" id="L219">                    exp = new Xor(total);</span>
<span class="nc" id="L220">                    break;</span>
                case &quot;not&quot;:
<span class="nc" id="L222">                    exp = new Not(total);</span>
<span class="nc" id="L223">                    break;</span>
                case &quot;and&quot;:
<span class="fc" id="L225">                    exp = new And(total);</span>
<span class="fc" id="L226">                    break;</span>
                case &quot;or&quot;:
<span class="fc" id="L228">                    exp = new Or(total);</span>
<span class="fc" id="L229">                    break;</span>
                case &quot;implies&quot;:
<span class="fc" id="L231">                    exp = new Implies(total);</span>
                    break;
            }
<span class="fc" id="L234">            return exp;</span>
<span class="nc" id="L235">        }catch (Exception e){</span>
<span class="nc" id="L236">            System.err.println(e.getMessage());</span>
<span class="nc" id="L237">            return null;</span>
        }
    }

    private boolean isAlphaNum(String s) {
        try{
<span class="fc" id="L243">            Integer.parseInt(s);</span>
<span class="fc" id="L244">            return true;</span>
<span class="fc" id="L245">        }catch (Exception ignored) {</span>
<span class="fc" id="L246">            return false;</span>
        }
    }

    /**
     * Sert à sauver la mémoire dans un fichier
     * @param path Chemin du fichier où sauvegarder la mémoire
     */
    public void save(String path){
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (alreadySaved)</span>
<span class="nc" id="L256">            return;</span>
        try{
<span class="fc" id="L258">            FileWriter writer = new FileWriter(path);</span>
<span class="fc" id="L259">            writer.write(getLog());</span>
<span class="fc" id="L260">            writer.close();</span>
<span class="fc" id="L261">            alreadySaved = true;</span>
<span class="nc" id="L262">        } catch (IOException e) {</span>
<span class="nc" id="L263">            System.err.println(e.getMessage());</span>
<span class="fc" id="L264">        }</span>
<span class="fc" id="L265">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>